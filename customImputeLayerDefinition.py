# -*- coding: utf-8 -*-
"""customImputeLayerDefinition.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1u6bQ1qL81qmNWvINfk3cSQI9uicrRM_7
"""

# Importing all necessary packages
import tensorflow as tf
import numpy as np

# Custom Keras Layer: ImputerLayer
# Purpose: Imputes missing (NaN) values with column-wise minimums
class ImputerLayer(tf.keras.layers.Layer):
    def __init__(self, **kwargs):
        super(ImputerLayer, self).__init__(**kwargs)
        self.impute_values = None  # Will hold learned minimums from adapt()

    def adapt(self, dataset):
        """
        Learns column-wise minimum values from the dataset, ignoring NaNs.
        Input: dataset (tf.data.Dataset) of batches with shape (batch_size, num_features)
        """

        def replace_nan_with_inf(batch):
            # Replacing NaNs with +inf so they don't affect tf.minimum()
            return tf.where(
                tf.math.is_nan(batch),
                tf.fill(tf.shape(batch), tf.constant(np.inf, dtype=batch.dtype)),
                batch
            )

        # Unbatching to flatten across all rows, then batching to ensure uniformity
        dataset = dataset.unbatch().batch(128)

        # Grabbing feature dimension from the first batch
        first_batch = next(iter(dataset))
        feature_dim = first_batch.shape[-1]

        # Computing minimums per feature dimension across all batches
        min_values = dataset.map(replace_nan_with_inf).reduce(
            initial_state=tf.fill([feature_dim], np.inf),
            reduce_func=lambda acc, x: tf.minimum(acc, tf.reduce_min(x, axis=0))
        )

        # Storing as non-trainable variable
        self.impute_values = tf.Variable(min_values, trainable=False)

    def call(self, inputs):
        """
        Replacing any NaNs in the inputs with the learned impute values.
        """
        return tf.where(tf.math.is_nan(inputs), self.impute_values, inputs)